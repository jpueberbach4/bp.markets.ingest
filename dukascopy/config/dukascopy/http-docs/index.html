<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OHLC - Pro Tooltips & Intelligent Scroll</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { font-family: sans-serif; background: #f4f4f9; padding: 20px; }
        #chart-container { 
            position: relative; background: white; border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); height: 600px; width: 100%;
        }
        #loader {
            display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.4); z-index: 10;
            justify-content: center; align-items: center; border-radius: 8px;
        }
        .controls { 
            margin-bottom: 20px; display: flex; gap: 10px; align-items: center; 
            background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        select, button { padding: 8px; border-radius: 4px; border: 1px solid #ccc; cursor: pointer; }
        #status-indicator { font-size: 12px; color: #888; margin-left: auto; }
        
        .floating-tooltip {
            width: 160px; height: 130px; position: absolute; display: none;
            padding: 10px; box-sizing: border-box; font-size: 12px; color: #131722;
            background-color: rgba(255, 255, 255, 0.95); text-align: left;
            z-index: 1000; pointer-events: none; border: 1px solid #007bff;
            border-radius: 4px; line-height: 1.6; box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .tooltip-row { display: flex; justify-content: space-between; }
        .tooltip-row span { font-weight: bold; }

        .spinner {
            width: 30px; height: 30px; border: 4px solid #f3f3f3; border-top: 4px solid #007bff;
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <h2>Interactive OHLC Stream</h2>

    <div class="controls">
        <label>Symbol:</label>
        <select id="symbolSelect" onchange="updateTimeframeOptions(); resetAndLoad();"></select>
        <label>Timeframe:</label>
        <select id="tfSelect" onchange="resetAndLoad()"></select>
        <button onclick="resetAndLoad()">Reset to Today</button>
        <div id="status-indicator"></div>
    </div>
    
    <div id="chart-container">
        <div id="loader"><div class="spinner"></div></div>
        <div id="chart" style="width: 100%; height: 100%;"></div>
        <div id="tooltip" class="floating-tooltip"></div>
    </div>

    <script>
        let symbolData = {}; 
        let currentAfterDate = new Date(); 
        let currentUntilDate = null; 
        let masterData = []; 
        let isFetching = false;
        let shouldResetZoomOnNextLoad = false;
        let hasMoreHistory = true;
        let gapRetryCount = 0; 

        const container = document.getElementById('chart-container');
        const tooltip = document.getElementById('tooltip');
        const chartElement = document.getElementById('chart');

        const chart = LightweightCharts.createChart(chartElement, {
            width: chartElement.clientWidth,
            height: 600,
            layout: { background: { type: LightweightCharts.ColorType.Solid, color: '#ffffff' }, textColor: '#333' },
            localization: {
                timeFormatter: (timestamp) => {
                    const date = new Date(timestamp * 1000);
                    return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
                },
            },
            timeScale: { 
                timeVisible: true, 
                secondsVisible: false, 
                borderColor: '#cccccc',
                shiftVisibleRangeOnNewBar: false 
            },
        });

        const candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
            upColor: '#4caf50', downColor: '#f44336', borderDownColor: '#f44336',
            borderUpColor: '#4caf50', wickDownColor: '#f44336', wickUpColor: '#4caf50',
        });

        chart.subscribeCrosshairMove(param => {
            if (param.point === undefined || !param.time || param.point.x < 0 || param.point.x > container.clientWidth) {
                tooltip.style.display = 'none';
            } else {
                const data = param.seriesData.get(candleSeries);
                if (data) {
                    tooltip.style.display = 'block';
                    const isBullish = data.close >= data.open;
                    const color = isBullish ? '#4caf50' : '#f44336';
                    const dateStr = new Date(data.time * 1000).toLocaleString('en-GB', { 
                        day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: false 
                    });
                    
                    tooltip.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 5px; color: #333; border-bottom: 1px solid #eee;">${dateStr}</div>
                        <div class="tooltip-row">Open: <span style="color: ${color}">${data.open.toFixed(4)}</span></div>
                        <div class="tooltip-row">High: <span style="color: ${color}">${data.high.toFixed(4)}</span></div>
                        <div class="tooltip-row">Low: <span style="color: ${color}">${data.low.toFixed(4)}</span></div>
                        <div class="tooltip-row">Close: <span style="color: ${color}">${data.close.toFixed(4)}</span></div>
                    `;

                    let left = param.point.x + 15;
                    if (left > container.clientWidth - 170) left = param.point.x - 175;
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = (param.point.y + 15) + 'px';
                }
            }
        });

        function formatServerDate(date) {
            const pad = (n) => n.toString().padStart(2, '0');
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ` +
                   `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
        }

        function checkIfChartFull() {
            if (isFetching || masterData.length === 0 || !hasMoreHistory) return;
            const timeScale = chart.timeScale();
            const visibleRange = timeScale.getVisibleRange();
            if (visibleRange && visibleRange.from <= masterData[0].time) paginateBack();
        }

        chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            requestAnimationFrame(checkIfChartFull);
        });

        window.__callbackData = function(response) {
            const statusIndicator = document.getElementById('status-indicator');
            if (response.result && Array.isArray(response.result) && response.result.length > 0) {
                gapRetryCount = 0; 
                const incoming = response.result.map(row => ({
                    time: Math.floor(new Date(row.time).getTime() / 1000),
                    open: row.open, high: row.high, low: row.low, close: row.close
                }));

                const combined = [...masterData, ...incoming];
                const uniqueMap = new Map();
                combined.forEach(item => { if(item.time) uniqueMap.set(item.time, item); });
                
                masterData = Array.from(uniqueMap.values()).sort((a, b) => a.time - b.time);
                candleSeries.setData(masterData);

                if (shouldResetZoomOnNextLoad) {
                    chart.timeScale().fitContent();
                    shouldResetZoomOnNextLoad = false;
                }

                statusIndicator.innerText = `Loaded: ${masterData.length} candles`;
                setTimeout(checkIfChartFull, 200); 
                isFetching = false;
                document.getElementById('loader').style.display = 'none';
            } else {
                if (gapRetryCount < 5) {
                    gapRetryCount++;
                    statusIndicator.innerText = `Searching history... (Attempt ${gapRetryCount}/5)`;
                    isFetching = false; 
                    // Even on initial load (masterData empty), paginateBack will now trigger
                    paginateBack(); 
                } else {
                    hasMoreHistory = false;
                    statusIndicator.innerText = `End of history reached (${masterData.length} candles)`;
                    isFetching = false;
                    document.getElementById('loader').style.display = 'none';
                }
            }
        };

        window.__callbackList = function(response) {
            if (response.status === "ok") {
                symbolData = response.result;
                const sel = document.getElementById('symbolSelect');
                sel.innerHTML = "";
                Object.keys(symbolData).sort().forEach(s => {
                    const opt = document.createElement('option');
                    opt.value = s; opt.innerHTML = s;
                    sel.appendChild(opt);
                });
                sel.value = "EUR-USD";
                updateTimeframeOptions();
                resetAndLoad();
            }
        };

        function resetAndLoad() {
            masterData = [];
            candleSeries.setData([]); 
            hasMoreHistory = true; 
            gapRetryCount = 0;
            shouldResetZoomOnNextLoad = true;
            chart.priceScale('right').applyOptions({ autoScale: true });
            const tf = document.getElementById('tfSelect').value;
            
            // Set Until to NOW and After to NOW - Offset
            currentUntilDate = new Date();
            currentAfterDate = new Date(currentUntilDate.getTime() - getTimeframeOffset(tf));
            loadData();
        }

        function paginateBack() {
            if (isFetching || !hasMoreHistory) return;
            const tf = document.getElementById('tfSelect').value;
            // Shift the window back: New Until is the old After
            currentUntilDate = new Date(currentAfterDate.getTime());
            currentAfterDate = new Date(currentAfterDate.getTime() - getTimeframeOffset(tf));
            loadData();
        }

        function loadData() {
            const sym = document.getElementById('symbolSelect').value;
            const tf = document.getElementById('tfSelect').value;
            if(!sym || !tf || isFetching) return;
            isFetching = true;
            document.getElementById('loader').style.display = 'flex';
            const afterStr = encodeURIComponent(formatServerDate(currentAfterDate));
            const untilStr = encodeURIComponent(formatServerDate(currentUntilDate));
            
            let url = `http://localhost:8000/ohlcv/1.0/select/${sym},${tf}/after/${afterStr}/until/${untilStr}/output/JSONP?order=asc&limit=1440&callback=__callbackData`;
            
            const old = document.getElementById('jsonp-script');
            if (old) old.remove();
            const s = document.createElement('script');
            s.id = 'jsonp-script'; s.src = url;
            document.body.appendChild(s);
        }

        function updateTimeframeOptions() {
            const sym = document.getElementById('symbolSelect').value;
            const tfS = document.getElementById('tfSelect');
            const prev = tfS.value;
            tfS.innerHTML = "";
            if (symbolData[sym]) {
                symbolData[sym].forEach(tf => {
                    const opt = document.createElement('option');
                    opt.value = tf; opt.innerHTML = tf;
                    tfS.appendChild(opt);
                });
                tfS.value = symbolData[sym].includes(prev) ? prev : "1h";
            }
        }

        function getTimeframeOffset(tf) {
            const day = 24 * 60 * 60 * 1000;
            switch (tf) {
                case '1Y': return 3650 * day;
                case '1M': return 365 * day;
                case '1W': return 100 * day;
                case '1d': return 50 * day;
                case '4h': return 15 * day;
                case '1h': return 6 * day;
                case '30m': return 3 * day;
                case '15m': return 3 * day;
                case '5m': return 2 * day;
                case '1m': return 1 * day;
                default:   return 4 * day;
            }
        }

        const s = document.createElement('script');
        s.src = "http://localhost:8000/ohlcv/1.0/list/output/JSONP?callback=__callbackList";
        document.body.appendChild(s);

        window.addEventListener('resize', () => {
            chart.applyOptions({ width: chartElement.clientWidth });
        });

        window.addEventListener('keydown', (event) => {
            if (masterData.length === 0) return;
            const timeScale = chart.timeScale();
            const visibleRange = timeScale.getVisibleLogicalRange();
            if (!visibleRange) return;
            const rangeWidth = visibleRange.to - visibleRange.from;

            if (event.key === 'PageUp') {
                event.preventDefault();
                timeScale.setVisibleLogicalRange({
                    from: visibleRange.from - rangeWidth,
                    to: visibleRange.to - rangeWidth
                });
            } else if (event.key === 'PageDown') {
                event.preventDefault();
                timeScale.setVisibleLogicalRange({
                    from: visibleRange.from + rangeWidth,
                    to: visibleRange.to + rangeWidth
                });
            }
        });
    </script>
</body>
</html>