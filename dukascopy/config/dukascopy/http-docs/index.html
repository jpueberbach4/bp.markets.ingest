<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OHLC - Intelligent Infinite Scroll</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { font-family: sans-serif; background: #f4f4f9; padding: 20px; }
        #chart-container { 
            position: relative; background: white; border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); height: 600px; width: 100%;
        }
        #loader {
            display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.4); z-index: 10;
            justify-content: center; align-items: center; border-radius: 8px;
        }
        .controls { 
            margin-bottom: 20px; display: flex; gap: 10px; align-items: center; 
            background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        select, button { padding: 8px; border-radius: 4px; border: 1px solid #ccc; cursor: pointer; }
        #status-indicator { font-size: 12px; color: #888; margin-left: auto; }
        .spinner {
            width: 30px; height: 30px; border: 4px solid #f3f3f3; border-top: 4px solid #007bff;
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div class="controls">
        <label>Symbol:</label>
        <select id="symbolSelect" onchange="updateTimeframeOptions(); resetAndLoad();"></select>
        <label>Timeframe:</label>
        <select id="tfSelect" onchange="resetAndLoad()"></select>
        <button onclick="resetAndLoad()">Reset to Today</button>
        <div id="status-indicator"></div>
    </div>
    
    <div id="chart-container">
        <div id="loader"><div class="spinner"></div></div>
        <div id="chart" style="width: 100%; height: 100%;"></div>
    </div>

    <script>
        let symbolData = {}; 
        let currentAfterDate = new Date(); 
        let currentUntilDate = null; 
        let masterData = []; 
        let isFetching = false;
        let shouldResetZoomOnNextLoad = false;
        let hasMoreHistory = true; // NEW: Prevents endless polling

        const chartElement = document.getElementById('chart');
        const chart = LightweightCharts.createChart(chartElement, {
            width: chartElement.clientWidth,
            height: 600,
            layout: { background: { type: LightweightCharts.ColorType.Solid, color: '#ffffff' }, textColor: '#333' },
            timeScale: { 
                timeVisible: true, 
                secondsVisible: false, 
                borderColor: '#cccccc',
                shiftVisibleRangeOnNewBar: false 
            },
        });

        const candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
            upColor: '#4caf50', downColor: '#f44336', borderDownColor: '#f44336',
            borderUpColor: '#4caf50', wickDownColor: '#f44336', wickUpColor: '#4caf50',
        });

        function formatServerDate(date) {
            const pad = (n) => n.toString().padStart(2, '0');
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ` +
                   `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
        }

        function checkIfChartFull() {
            // STOP if we already know there is no more history
            if (isFetching || masterData.length === 0 || !hasMoreHistory) return;

            const timeScale = chart.timeScale();
            const visibleRange = timeScale.getVisibleRange();
            
            if (!visibleRange) return;

            if (visibleRange.from <= masterData[0].time) {
                paginateBack();
            }
        }

        chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            requestAnimationFrame(checkIfChartFull);
        });

        window.__callbackData = function(response) {
            const statusIndicator = document.getElementById('status-indicator');
            
            if (response.result && Array.isArray(response.result) && response.result.length > 0) {
                const incoming = response.result.map(row => ({
                    time: Math.floor(new Date(row.time).getTime() / 1000),
                    open: row.open, high: row.high, low: row.low, close: row.close
                }));

                const combined = [...masterData, ...incoming];
                const uniqueMap = new Map();
                combined.forEach(item => { if(item.time) uniqueMap.set(item.time, item); });
                
                masterData = Array.from(uniqueMap.values()).sort((a, b) => a.time - b.time);
                candleSeries.setData(masterData);

                if (shouldResetZoomOnNextLoad) {
                    const lastIdx = masterData.length - 1;
                    chart.timeScale().setVisibleLogicalRange({
                        from: lastIdx - 100, 
                        to: lastIdx + 5      
                    });
                    shouldResetZoomOnNextLoad = false;
                }

                statusIndicator.innerText = `Loaded: ${masterData.length} candles`;
                setTimeout(checkIfChartFull, 200); 
            } else {
                // If the API returns nothing, we've hit the beginning of time for this asset
                hasMoreHistory = false;
                statusIndicator.innerText = `End of history reached (${masterData.length} candles)`;
                console.log("No more history available on server.");
            }

            isFetching = false;
            document.getElementById('loader').style.display = 'none';
        };

        window.__callbackList = function(response) {
            if (response.status === "ok") {
                symbolData = response.result;
                const sel = document.getElementById('symbolSelect');
                sel.innerHTML = "";
                Object.keys(symbolData).sort().forEach(s => {
                    const opt = document.createElement('option');
                    opt.value = s; opt.innerHTML = s;
                    sel.appendChild(opt);
                });
                sel.value = "EUR-USD";
                updateTimeframeOptions();
                resetAndLoad();
            }
        };

        function resetAndLoad() {
            masterData = [];
            hasMoreHistory = true; // Reset flag for new search
            shouldResetZoomOnNextLoad = true;
            const tf = document.getElementById('tfSelect').value;
            currentAfterDate = new Date(Date.now() - getTimeframeOffset(tf));
            currentUntilDate = null;
            loadData();
        }

        function paginateBack() {
            if (isFetching || !hasMoreHistory) return;
            const tf = document.getElementById('tfSelect').value;
            const offset = getTimeframeOffset(tf);
            currentUntilDate = new Date(currentAfterDate.getTime());
            currentAfterDate = new Date(currentAfterDate.getTime() - offset);
            loadData();
        }

        function loadData() {
            const sym = document.getElementById('symbolSelect').value;
            const tf = document.getElementById('tfSelect').value;
            if(!sym || !tf || isFetching) return;

            isFetching = true;
            document.getElementById('loader').style.display = 'flex';

            const afterStr = encodeURIComponent(formatServerDate(currentAfterDate));
            let url = `http://localhost:8000/ohlcv/1.0/select/${sym},${tf}/after/${afterStr}`;
            if (currentUntilDate) url += `/until/${encodeURIComponent(formatServerDate(currentUntilDate))}`;
            url += `/output/JSONP?order=asc&limit=1000&callback=__callbackData`;
            
            const old = document.getElementById('jsonp-script');
            if (old) old.remove();
            const s = document.createElement('script');
            s.id = 'jsonp-script'; s.src = url;
            document.body.appendChild(s);
        }

        function updateTimeframeOptions() {
            const sym = document.getElementById('symbolSelect').value;
            const tfS = document.getElementById('tfSelect');
            const prev = tfS.value;
            tfS.innerHTML = "";
            if (symbolData[sym]) {
                symbolData[sym].forEach(tf => {
                    const opt = document.createElement('option');
                    opt.value = tf; opt.innerHTML = tf;
                    tfS.appendChild(opt);
                });
                tfS.value = symbolData[sym].includes(prev) ? prev : "1h";
            }
        }

        function getTimeframeOffset(tf) {
            const day = 24 * 60 * 60 * 1000;
            switch (tf) {
                case '1Y': return 10000 * day;
                case '1M': return 1000 * day;
                case '1W': return 300 * day;
                case '1d': return 100 * day;
                case '4h': return 25 * day;
                case '1h': return 10 * day;
                default:   return 2 * day;
            }
        }

        const s = document.createElement('script');
        s.src = "http://localhost:8000/ohlcv/1.0/list/output/JSONP?callback=__callbackList";
        document.body.appendChild(s);

        window.addEventListener('resize', () => {
            chart.applyOptions({ width: chartElement.clientWidth });
        });
    </script>
</body>
</html>