<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trading Interface - Charts</title>
    <script src="scripts/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --bg-main: #f0f3fa; --sidebar-dark: #131722; --accent-blue: #2962ff;
            --text-gray: #787b86; --white: #ffffff; --border-color: #e0e3eb;
        }

        body { 
            font-family: -apple-system, system-ui, sans-serif; background: var(--bg-main); 
            margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden;
        }

        header {
            background: var(--sidebar-dark); color: white; padding: 10px 20px;
            display: flex; align-items: center; justify-content: space-between; height: 50px;
        }

        .main-container { display: flex; flex: 1; overflow: hidden; }

        .sidebar { 
            width: 300px; background: var(--white); border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column; padding: 15px; overflow-y: auto;
        }

        .control-group { margin-bottom: 15px; }
        label { font-size: 11px; color: var(--text-gray); text-transform: uppercase; font-weight: 700; display: block; margin-bottom: 5px; }
        select, input { width: 100%; padding: 6px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 13px; box-sizing: border-box; }
        
        .param-box { background: #f8f9fd; padding: 10px; border-radius: 4px; border: 1px dashed var(--border-color); margin-top: 5px; }
        .indicator-tag { 
            background: #e3e9ff; color: var(--accent-blue); padding: 4px 8px; border-radius: 12px; 
            font-size: 11px; font-weight: 600; display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;
        }
        .add-btn { 
            background: var(--white); border: 1px solid var(--accent-blue); color: var(--accent-blue); 
            padding: 6px; border-radius: 4px; font-size: 11px; font-weight: 700; cursor: pointer; width: 100%; margin-top: 5px;
        }

        div[id^="tv-attr-logo"], 
        .tv-embed-widget-wrapper__attribution,
        #main-chart-container a[href*="tradingview.com"] {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        #chart-legend {
            position: absolute;
            z-index: 1000;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            color: #131722;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: none;
            line-height: 1.4;
        }

        .legend-ohlcv { font-weight: bold; border-bottom: 1px solid #eee; margin-bottom: 6px; padding-bottom: 4px; }
        .legend-item { display: flex; justify-content: space-between; margin-bottom: 2px; gap: 15px; font-size: 11px; }

        #content-wrapper { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden; 
        }

        #main-chart-container { 
            flex: 1 1 auto; 
            min-height: 0; 
            position: relative; 
        }

        #panel-container { 
            flex: 0 0 auto; 
            display: flex; 
            flex-direction: column;
            background: #fcfcfc;
            overflow-y: auto;
            max-height: 60vh;
        }

        .indicator-panel { 
            position: relative;
            height: 130px; 
            flex-shrink: 0;
            border-top: 1px solid #444;
            background: white;
            transform: translateZ(0);
            backface-visibility: hidden;
            contain: strict;
        }

        .panel-title {
            position: absolute;
            top: 5px;
            left: 8px;
            z-index: 5;
            font-size: 11px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            color: #131722;
            border: 1px solid #6e6f70;
            background: rgba(230, 228, 228, 0.7);
            padding: 2px 4px;
            border-radius: 2px;
            pointer-events: none;
            font-weight: 600;
            text-transform: uppercase;
            overflow-anchor: none;
        }

        .sidebar-footer { 
            padding: 15px 20px; 
            border-top: 1px solid var(--border-color); 
            background: #fafbfc; 
            text-align: center; 
            margin-top: auto;
        }

        #short_message{
            height: 16px;
            font-size: 14px;
        }

        .attribution { 
            font-size: 14px; 
            color: var(--text-gray); 
            text-decoration: none; 
        }

        .attribution strong { 
            color: #5d606b; 
        }

        #loader {
            display: none; 
            position: absolute; 
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0); 
            z-index: 100; 
            justify-content: center; 
            align-items: center;
            pointer-events: none; 
        }

        .spinner {
            width: 24px; height: 24px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        #export-modal {
            display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); align-items: center; justify-content: center;
        }
        .modal-content {
            background: white; padding: 25px; border-radius: 8px; width: 320px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        .modal-content h3 { margin-top: 0; font-size: 16px; color: var(--sidebar-dark); }
        .export-field { margin-bottom: 15px; }
        .export-checkboxes { display: flex; gap: 15px; margin-bottom: 20px; font-size: 12px; }
        .cancel-btn { 
            background: #e0e3eb; color: #131722; border: none; padding: 10px; 
            border-radius: 4px; font-weight: 600; cursor: pointer; width: 48%; 
        }
        .exec-btn { 
            background: var(--accent-blue); color: white; border: none; padding: 10px; 
            border-radius: 4px; font-weight: 600; cursor: pointer; width: 48%; 
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Dark Theme */
        body.dark-theme {
            --bg-main: #0b0e14;
            --white: #131722;
            --sidebar-dark: #0b0e14;
            --border-color: #2a2e39;
            --text-gray: #b2b5be;
            background-color: var(--bg-main);
        }

        body.dark-theme #panel-container {
            background-color: var(--bg-main);
        }

        body.dark-theme .indicator-panel {
            background-color: var(--white);
            border-top: 1px solid var(--border-color);
            margin-top: 0 !important; 
            padding-bottom: 2px;
        }

        body.dark-theme select, 
        body.dark-theme input {
            background-color: #1e222d !important;
            color: #d1d4dc !important;
            border: 1px solid #363c4e !important;
        }

        body.dark-theme .sidebar {
            background-color: #131722;
            border-right: 1px solid #2a2e39;
        }

        body.dark-theme .param-box { 
            background: #131722; 
            border: 1px dashed #363c4e; 
        }

        body.dark-theme .indicator-tag { 
            background: #2962ff22; 
            color: #2962ff; 
            border: 1px solid #2962ff44; 
        }

        body.dark-theme #chart-legend { 
            background: rgba(19, 23, 34, 0.85); 
            color: #d1d4dc; 
            border-color: #363c4e; 
            backdrop-filter: blur(4px);
        }

        body.dark-theme .panel-title { 
            background: #2a2e39; 
            color: #d1d4dc; 
            border: 1px solid #363c4e;
        }

        body.dark-theme .sidebar-footer {
            background-color: #131722 !important;
            border-top: 1px solid #2a2e39 !important;
            color: #d1d4dc !important;
        }

        body.dark-theme .sidebar-footer button {
            background-color: #1e222d !important;
            color: #d1d4dc !important;
            border: 1px solid #363c4e !important;
        }

        body.dark-theme .sidebar-footer button:hover {
            background-color: #2a2e39 !important;
            border-color: #2962ff !important;
        }

        body.dark-theme .sidebar-footer span,
        body.dark-theme .sidebar-footer label {
            color: #b2b5be !important;
        }

        body.dark-theme #calendarModal > div {
            background-color: #1e222d !important;
            color: #d1d4dc !important;
            border: 1px solid #363c4e !important;
            box-shadow: 0 16px 32px rgba(0,0,0,0.5) !important;
        }

        body.dark-theme #calendarModal h3 {
            color: #ffffff !important;
        }

        body.dark-theme #calendarInput {
            background-color: #131722 !important;
            border: 1px solid #363c4e !important;
            color: #ffffff !important;
            padding: 10px !important;
            border-radius: 4px !important;
            color-scheme: dark !important; 
        }

        body.dark-theme #calendarOk {
            background-color: #2962ff !important;
            color: #ffffff !important;
        }

        body.dark-theme #calendarOk:hover {
            background-color: #1e4bd8 !important;
        }

        body.dark-theme #closeModal {
            color: #b2b5be !important;
        }

        body.dark-theme #export-modal > .modal-content {
            background-color: #1e222d !important;
            color: #d1d4dc !important;
            border: 1px solid #363c4e !important;
            box-shadow: 0 16px 32px rgba(0,0,0,0.5) !important;
        }

        body.dark-theme #export-modal h3 {
            color: #ffffff !important;
        }

        body.dark-theme #export-modal input,
        body.dark-theme #export-modal select {
            background-color: #131722 !important;
            border: 1px solid #363c4e !important;
            color: #ffffff !important;
        }

        body.dark-theme #export-modal .exec-btn {
            background-color: #2962ff !important;
            color: #ffffff !important;
        }

        body.dark-theme #export-modal .cancel-btn {
            background-color: #363c4e !important;
            color: #d1d4dc !important;
        }

    </style>
</head>
<body>
    <header>
        <h2 style="margin:0; font-size: 18px;">Interactive Stream</h2>
        <button id="calendarBtn" style="background: var(--accent-blue); color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-weight: 500;">ðŸ“… Jump to Date</button>
        <button id="themeToggle" style="background: #313339; color: white; border: 1px solid #444; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-weight: 500; margin-left: 10px;">ðŸŒ™ Dark Mode</button>
        <div id="status-indicator" style="font-size: 11px; opacity: 0.8;">Initialising...</div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <div class="control-group">
                <label>Symbol</label>
                <select id="symbolSelect" onchange="updateTimeframeOptions(); resetAndLoad(true);"></select>
            </div>
            <div class="control-group">
                <label>Interval</label>
                <select id="tfSelect" onchange="resetAndLoad(true)"></select>
            </div>

            <hr style="border:0; border-top:1px solid #eee; margin: 15px 0;">

            <div class="control-group">
                <label>Add Indicator</label>
                <select id="indicatorSelect" onchange="renderParams()"></select>
                <div id="params" class="param-box"></div>
                <button class="add-btn" onclick="addToChain()">+ Add to Chart</button>
            </div>

            <div class="control-group">
                <label>Active Indicators</label>
                <div id="chain-list"></div>
            </div>

            <button onclick="resetAndLoad(false)" style="margin-top:auto; background: var(--accent-blue); color:white; border:none; padding:10px; border-radius:4px; font-weight:600; cursor:pointer;">Update View</button>

            <button onclick="openExportModal()" style="margin-top:10px; background: #313339; color:white; border:none; padding:10px; border-radius:4px; font-weight:600; cursor:pointer; width:100%;">Export View</button>

            <button onclick="copyUrl()" style="margin-top:10px; background: #313339; color:white; border:none; padding:10px; border-radius:4px; font-weight:600; cursor:pointer; width:100%;">Copy URL</button>

            <div class="sidebar-footer">
                <div id="short_message"></div>
                <a href="https://www.dukascopy.com" target="_blank" class="attribution">
                    Market data by <strong>Dukascopy</strong>
                </a>
            </div>
        </div>

        <div id="content-wrapper">
            <div id="loader"><div class="spinner"></div></div>
            <div id="chart-legend"></div>
            <div id="main-chart-container"></div>
            <div id="panel-container"></div>
        </div>
    </div>

    <div id="export-modal">
        <div class="modal-content">
            <h3>Export Settings</h3>
            <div class="export-field">
                <label>Start Date (After)</label>
                <input type="text" id="export-after" placeholder="YYYY-MM-DD HH:MM:SS">
            </div>
            <div class="export-field">
                <label>Total Records (Limit, max. 100000)</label>
                <input type="number" id="export-limit" value="1000">
            </div>
            <div class="export-field">
                <label>Order</label>
                <select id="export-order">
                    <option value="asc">Ascending</option>
                    <option value="desc">Descending</option>
                </select>
            </div>
            <div class="export-checkboxes">
                <label><input type="checkbox" id="export-mt4"> MT4 CSV</label>
                <label><input type="checkbox" id="export-skiplast"> SkipLast</label>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <button class="cancel-btn" onclick="document.getElementById('export-modal').style.display='none'">Cancel</button>
                <button class="exec-btn" onclick="runExport()">Download</button>
            </div>
        </div>
    </div>

    <div id="calendarModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999; align-items: center; justify-content: center;">
        <div style="background: var(--white); width: 320px; border-radius: 8px; overflow: hidden; box-shadow: 0 10px 25px rgba(0,0,0,0.5);">
            <div style="background: var(--sidebar-dark); color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center;">
                <h3 style="margin: 0; font-size: 16px;">Jump to Date</h3>
                <span id="closeModal" style="cursor: pointer; font-size: 20px;">&times;</span>
            </div>
            <div style="padding: 20px;">
                <label style="display: block; color: var(--text-gray); font-size: 12px; margin-bottom: 8px;">SELECT DATE</label>
                <input type="date" id="calendarInput" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; font-family: inherit; margin-bottom: 20px; box-sizing: border-box;">
                <button id="calendarOk" style="width: 100%; background: var(--accent-blue); color: white; border: none; padding: 12px; border-radius: 4px; font-weight: bold; cursor: pointer;">OK</button>
            </div>
        </div>
    </div>
<script>
    let isDark = false;
    let symbolData = {}; 
    let indicatorMeta = {};
    let chain = []; 
    let masterData = []; 
    let isFetching = false;
    let requestDirection = null;

    let hasMoreHistory = true;
    let gapRetryCount = 0;
    const maxGapRetries = 10;
    let bufferLimit = 20; 
    const MS_PER_DAY = 24 * 60 * 60 * 1000;

    let rightPriceScaleWidth = 90;
    let mainChart, candleSeries, volumeSeries;
    let overlaySeriesMap = {}; 
    let panelCharts = {};      
    const mainContainer = document.getElementById('main-chart-container');

    function openExportModal() {
        const modal = document.getElementById('export-modal');
        const dateInput = document.getElementById('export-after');
        
        if (masterData.length > 0) {
            dateInput.value = formatUnixToLiteral(masterData[0].time);
        } else {
            dateInput.value = formatUnixToLiteral(Math.floor(Date.now() / 1000));
        }
        
        modal.style.display = 'flex';
    }

    function runExport() {
        const sym = document.getElementById('symbolSelect').value;
        let tf = document.getElementById('tfSelect').value;
        
        if (document.getElementById('export-skiplast').checked) tf += ':skiplast';
        const output = document.getElementById('export-mt4').checked ? 'CSV/MT4' : 'CSV';
        
        const after = encodeURIComponent(document.getElementById('export-after').value);
        const limit = document.getElementById('export-limit').value;
        const order = document.getElementById('export-order').value;
        
        const chainStr = chain.length ? `[${chain.map(i => `${i.name}(${i.params.join(',')})`).join(':')}]` : "";
        
        const exportUrl = `/ohlcv/1.1/select/${sym},${tf}${chainStr}/after/${after}/output/${output}?limit=${limit}&order=${order}`;
        
        window.location.href = exportUrl;
    }


    function initCharts() {
        mainChart = LightweightCharts.createChart(mainContainer, {
            width: mainContainer.clientWidth,
            height: mainContainer.clientHeight,
            localization: { timeFormatter: (ts) => formatUnixToLiteral(ts) },
            layout: { background: { color: '#ffffff' }, textColor: '#131722', attributionLogo: false },
            timeScale: { timeVisible: true, borderColor: '#e0e3eb', shiftVisibleRangeOnNewBar: false },
            rightPriceScale: { 
                borderVisible: false, minimumWidth: rightPriceScaleWidth
            },
        });

        const resizeObserver = new ResizeObserver(entries => {
            if (entries.length === 0 || !entries[0].contentRect) return;
            const { width, height } = entries[0].contentRect;
            mainChart.applyOptions({ width, height });
            Object.values(panelCharts).forEach(p => p.chart.applyOptions({ width }));
        });

        resizeObserver.observe(mainContainer);

        candleSeries = mainChart.addSeries(LightweightCharts.CandlestickSeries, {
            upColor: '#26a69a', downColor: '#ef5350', borderVisible: false,
            wickUpColor: '#26a69a', wickDownColor: '#ef5350',
            priceFormat: { type: 'price', precision: 6, minMove: 0.000001 },
        });
        
        volumeSeries = mainChart.addSeries(LightweightCharts.HistogramSeries, {
            color: '#26a69a', priceFormat: { type: 'volume' }, priceScaleId: '',
        });
        volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });

        mainChart.timeScale().applyOptions({
            shiftVisibleRangeOnNewBar: false,
        });
        const legend = document.getElementById('chart-legend');
        mainChart.subscribeCrosshairMove(param => {
            if (!param.time || !param.point || param.point.x < 0 || param.point.y < 0) {
                legend.style.display = 'none';
                return;
            }

            const data = param.seriesData.get(candleSeries);
            const volData = param.seriesData.get(volumeSeries);
            const masterPoint = masterData.find(d => d.time === param.time);
            if (!data || !masterPoint) return;

            legend.style.display = 'block';
            legend.style.left = (param.point.x + 165) + 'px';
            legend.style.top = (param.point.y + 65) + 'px';

            let html = `<div class="legend-ohlcv">`;
            html += `<div style="color: var(--text-gray); font-size: 10px; margin-bottom: 4px;">${formatUnixToLiteral(param.time)}</div>`;
            html += `O: ${data.open} H: ${data.high}<br>L: ${data.low} C: ${data.close}`;
            if (volData) html += `<br>Vol: ${volData.value.toLocaleString()}`;
            html += `</div>`;
            
            if (masterPoint.indicators) {
                Object.entries(masterPoint.indicators).forEach(([fullKey, val]) => {
                        const parts = fullKey.split('_');
                        const name = parts[0];
                        const suffix = parts[parts.length - 1];
                        
                        const params = parts.slice(1, -1).filter(p => !isNaN(p) && p !== "");
                        
                        const settings = params.length > 0 ? `(${params.join(',')})` : '';
                        const color = getSeriesColor(fullKey);

                        html += `<div class="legend-item">
                            <span>${name}${settings} ${suffix}</span>
                            <b style="color:${color}">${Number(val).toFixed(5)}</b>
                        </div>`;
                });
            }
            legend.innerHTML = html;
        });

        mainChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            if (isFetching || masterData.length === 0) return;
            const logicalRange = mainChart.timeScale().getVisibleLogicalRange();
            if (!logicalRange) return;

            syncBufferLimit();

            if (logicalRange.from < 10 && hasMoreHistory) {
                loadData('history', masterData[0].time * 1000);
            }
            if (logicalRange.to > masterData.length - 10) {
                loadData('future', (masterData[masterData.length - 1].time * 1000)+1);
            }
        });
        
        window.addEventListener('resize', syncBufferLimit);
        syncBufferLimit(); 

    }

    function syncBufferLimit() {
        const container = document.getElementById('main-chart-container');
        const spacing = mainChart.timeScale().options().barSpacing || 6;
        const visibleBars = Math.ceil(container.offsetWidth / spacing);
        const target = Math.max(3000, visibleBars * 3); 

        if (Math.abs(target - bufferLimit) > 200) {
            bufferLimit = target;
        }
    }

    function renderParams() {
        const indKey = document.getElementById('indicatorSelect').value;
        const meta = indicatorMeta[indKey];
        const container = document.getElementById('params');
        container.innerHTML = (meta && meta.defaults) ? 
            Object.keys(meta.defaults).map(k => `<div style="margin-bottom:5px"><label style="font-size:9px;display:block;">${k}</label><input type="text" id="p_${k}" value="${meta.defaults[k]}" style="width:100%;box-sizing:border-box;"></div>`).join('') :
            '<span style="color:#999; font-size:11px">No parameters</span>';
    }

    function addToChain() {
        const indKey = document.getElementById('indicatorSelect').value;
        const meta = indicatorMeta[indKey];
        if (!meta) return;
        const params = meta.defaults ? Object.keys(meta.defaults).map(k => document.getElementById(`p_${k}`).value) : [];
        
        chain.push({ name: indKey, params, meta });
        updateChainUI();

        const timeScale = mainChart.timeScale();
        const visibleRange = timeScale.getVisibleLogicalRange();
        
        let referenceTime = Date.now();
        let visibleBarCount = 1000;

        if (visibleRange !== null && masterData.length > 0) {
            visibleBarCount = Math.ceil(visibleRange.to - visibleRange.from) + 10;
            const firstVisibleIdx = Math.max(0, Math.floor(visibleRange.from));
            if (masterData[firstVisibleIdx]) {
                referenceTime = masterData[firstVisibleIdx].time * 1000;
            } else {
                referenceTime = masterData[0].time * 1000;
            }
        }

        Object.values(overlaySeriesMap).forEach(s => mainChart.removeSeries(s));
        overlaySeriesMap = {};
        masterData = []; 
        loadData('initial', referenceTime, visibleBarCount); 
    }

    function updateChainUI() {
        document.getElementById('chain-list').innerHTML = chain.map((item, idx) => `
            <div class="indicator-tag">${item.name}(${item.params.join(',')})
                <span style="cursor:pointer; margin-left:8px; font-weight:bold;" onclick="removeFromChain(${idx})">âœ•</span>
            </div>`).join('');
    }

    function removeFromChain(idx) {
        chain.splice(idx, 1);
        updateChainUI();
        resetAndLoad(true);
    }

    function getDataUri(direction, referenceTs, limit = 1000, type = "JSONP"){
        const sym = document.getElementById('symbolSelect').value;
        const tf = document.getElementById('tfSelect').value;
        if(!sym || !tf) return;
        
        const chainStr = chain.length ? `[${chain.map(i => `${i.name}(${i.params.join(',')})`).join(':')}]` : "";
        let url = `${location.protocol}//${location.hostname}:${location.port}/ohlcv/1.1/select/${sym},${tf}${chainStr}`;
        
        const fetchLimit = Math.min(limit, 5000);

        let callback = "";
        if (type == "JSONP") {
            callback = "&callback=__callbackData";
        }

        let params = `output/${type}?limit=${fetchLimit}${callback}&subformat=3`;

        if (direction === 'history') {
            url += `/until/${referenceTs || Date.now()}`;
            params += `&order=desc`;
        } else if (direction === 'future') {
            url += `/after/${referenceTs || (masterData.length > 0 ? masterData[masterData.length-1].time * 1000 : Date.now())}`;
            params += `&order=asc`;
        } else {
            if (referenceTs) {
                url += `/after/${referenceTs}`;
                params += `&order=asc`;
            } else {
                url += `/until/${Date.now()}`;
                params += `&order=desc`;
            }
        }
        url = `${url}/${params}`;
        return url;
    }

    async function copyToClipboard(text) {
        try {
            await navigator.clipboard.writeText(text);
            document.getElementById('short_message').innerHTML = 'Copied!'
        } catch (err) {
            document.getElementById('short_message').innerHTML = 'Failed'

        }
        setTimeout(() => {
            document.getElementById('short_message').innerHTML = '';
        }, 500)
    }

    function copyUrl() {
        let url = getDataUri('future', masterData[0].time*1000, 1000, "JSON");
        copyToClipboard(url);
    }

    function loadData(direction, referenceTs, limit = 1000) {
        if (isFetching) return;
        const sym = document.getElementById('symbolSelect').value;
        const tf = document.getElementById('tfSelect').value;
        if(!sym || !tf) return;

        isFetching = true;
        requestDirection = direction;
        document.getElementById('loader').style.display = 'flex';

        let url = getDataUri(direction, referenceTs, limit = 1000);

        const s = document.createElement('script');
        s.src = url;
        document.body.appendChild(s);
    }

    window.__callbackData = function(response) {
        isFetching = false;
        document.getElementById('loader').style.display = 'none';
        
        if (response.result && response.result.time && response.result.time.length > 0) {
            gapRetryCount = 0;
            const res = response.result;
            const cols = response.columns;

            const incoming = res.time.map((t, i) => {
                const item = {
                    time: t / 1000,
                    open: res.open[i], high: res.high[i], low: res.low[i], close: res.close[i],
                    value: res.volume[i],
                    indicators: {}
                };
                cols.forEach((col, idx) => {
                    if (idx > 5) item.indicators[col] = res[col][i];
                });
                return item;
            });

            const timeScale = mainChart.timeScale();
            const logicalRange = timeScale.getVisibleLogicalRange();

            let combined = [...masterData, ...incoming];
            const uniqueMap = new Map();
            combined.forEach(d => uniqueMap.set(d.time, d));
            const newData = Array.from(uniqueMap.values()).sort((a, b) => a.time - b.time);

            const lastOldTime = masterData.length > 0 ? masterData[masterData.length - 1].time : null;
            const addedToLeft = newData.findIndex(d => d.time === (masterData[0] ? masterData[0].time : null));
            const countAddedLeft = (addedToLeft === -1 || masterData.length === 0) ? 0 : addedToLeft;

            const oldLastIndex = lastOldTime ? newData.findIndex(d => d.time === lastOldTime) : -1;
            const countAddedRight = (oldLastIndex === -1) ? 0 : (newData.length - 1 - oldLastIndex);

            masterData = newData;

            console.log(requestDirection)

            if (masterData.length > bufferLimit) {
                
                if (requestDirection === 'future' || requestDirection === 'initial') {
                    masterData = masterData.slice(-bufferLimit);
                } 
                else if (requestDirection === 'history') {
                    masterData = masterData.slice(0, Math.max(bufferLimit, logicalRange.to + 100));
                }
            }

            updateChartUI(cols, requestDirection);

            if (window.anchorTime) {
                // This stuff is wayyyyy harder than even the most complex part of the ETL pipeline.
                // I dont know this library very well....
                const timeScale = mainChart.timeScale();
                const newLeftIndex = masterData.findIndex(d => d.time === window.anchorTime);
                console.log('anchoring: ' + window.anchorTime)
                if (newLeftIndex !== -1) {
                    timeScale.setVisibleLogicalRange({
                        from: newLeftIndex,
                        to: newLeftIndex + (window.savedWidth || 50)
                    });
                }
                window.anchorTime = null;
                window.savedWidth = null;
            }

            if (logicalRange !== null) {
                if (requestDirection === 'history' && countAddedLeft > 0) {
                    timeScale.setVisibleLogicalRange({ 
                        from: logicalRange.from + countAddedLeft, 
                        to: logicalRange.to + countAddedLeft 
                    });
                } 
            }

        } else if (gapRetryCount < maxGapRetries) {
            gapRetryCount++;
            const currentTs = requestDirection === 'history' ? parseInt(response.options.until) : parseInt(response.options.after);
            const nextTs = requestDirection === 'history' ? currentTs - MS_PER_DAY : currentTs + MS_PER_DAY;
            loadData(requestDirection, nextTs);
        }
    };

    function getTitleString(col) {
        const parts = col.split('_');
        const name = parts[0].toUpperCase();
        const params = parts.filter(p => !isNaN(p) && p !== "");
        const titleStr = params.length > 0 ? `${name} (${params.join(',')})` : name;
        return titleStr;
    }

    function updateChartUI(cols = [], requestDirection) {

        candleSeries.setData(masterData.map(d => ({
            time: d.time, open: d.open, high: d.high, low: d.low, close: d.close
        })));
        
        volumeSeries.setData(masterData.map(d => ({
            time: d.time, value: d.value, 
            color: d.close >= d.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
        })));

        const statusEl = document.querySelector('#status-indicator');
        if (statusEl) {
            statusEl.innerText = `Buffer: ${masterData.length} bars`;
        }

        cols.forEach((col, idx) => {
            if (idx <= 5) return; 

            const rawName = col.split('_')[0]; 
            const meta = indicatorMeta[rawName];
            if (!meta) return;

            const mainParts = col.split('__');
            const basePart = mainParts[0]; 
            const displayTitle = (mainParts.length > 1) 
                ? mainParts[1] 
                : basePart.split('_')[0];

            const targetPanel = (meta.meta && meta.meta.panel === 1) ? 1 : 0;

            if (targetPanel === 0) {
                if (!overlaySeriesMap[col]) {
                    overlaySeriesMap[col] = mainChart.addSeries(LightweightCharts.LineSeries, {
                        color: getSeriesColor(col),
                        lineWidth: 1,
                        title: displayTitle,
                        priceFormat: { type: 'price', precision: 6, minMove: 0.000001 },
                    });
                }
                overlaySeriesMap[col].setData(masterData.map(d => ({ 
                    time: d.time, value: d.indicators[col] 
                })).filter(v => v.value !== null));

            } else {
                const panelKey = basePart;
                if (!panelCharts[panelKey]) createPanel(panelKey);
                
                const pObj = panelCharts[panelKey];

                if (pObj.titleElement && !pObj.series[col]) {
                    pObj.titleElement.innerText = params.length > 0 ? `${nameOnly} (${params.join(',')})` : nameOnly;
                }

                if (!pObj.series[col]) {
                    pObj.series[col] = pObj.chart.addSeries(
                        col.includes('hist') ? LightweightCharts.HistogramSeries : LightweightCharts.LineSeries, 
                        {
                            color: getSeriesColor(col),
                            title: displayTitle,
                            lineWidth: 1,
                            priceFormat: { type: 'price', precision: 6, minMove: 0.000001 }
                        }
                    );
                }

                const seriesData = masterData.map(d => {
                    const item = { time: d.time, value: d.indicators[col] };
                    if (col.includes('hist')) {
                        item.color = d.indicators[col] >= 0 ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)';
                    }
                    return item;
                }).filter(v => v.value !== null);

                pObj.series[col].setData(seriesData);
            }
        });
    }

    function createPanel(id) {
        const container = document.getElementById('panel-container');
        const div = document.createElement('div');
        div.className = 'indicator-panel';
        div.style.height = '130px';
        div.style.width = '100%';
        div.style.marginTop = '5px';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'panel-title';
        titleDiv.id = `title-${id}`;
        titleDiv.innerText = getTitleString(id.toUpperCase());
        div.appendChild(titleDiv);

        container.appendChild(div);
        
        const panelColors = isDark ? 
            { back: '#131722', text: '#d1d4dc', grid: '#2a2e39' } : 
            { back: '#ffffff', text: '#131722', grid: '#f0f3fa' };

        const chart = LightweightCharts.createChart(div, {
            width: div.clientWidth, height: 130,
            layout: { 
                background: { color: panelColors.back }, 
                textColor: panelColors.text, 
                attributionLogo: false 
            },
            grid: {
                vertLines: { color: panelColors.grid },
                horzLines: { color: panelColors.grid },
            },
            timeScale: { 
                visible: false,
                shiftVisibleRangeOnNewBar: false
            },
            rightPriceScale: { borderVisible: false, minimumWidth: rightPriceScaleWidth },
        });
        
        panelCharts[id] = { chart, series: {} };
        
        panelCharts[id] = { chart, series: {} };
        const currentRange = mainChart.timeScale().getVisibleLogicalRange();
        if (currentRange) {
            chart.timeScale().setVisibleLogicalRange(currentRange);
        }
        mainChart.timeScale().subscribeVisibleLogicalRangeChange(range => {
            if (range) {
                chart.timeScale().setVisibleLogicalRange(range);
            }
        });
    }

    function getSeriesColor(col) {
        const palette = {
            'stoch_k': '#2962FF',    // Blue
            'stoch_d': '#FF6D00',    // Orange
            'signal': '#FF5252',     // Red
            'macd': '#2962FF',       // Blue
            'upper': '#787b86',      // Gray
            'lower': '#787b86',      // Gray
            'middle': '#FF9800',     // Amber
            'rsi': '#9c27b0',        // Purple
            'hist': '#26a69a',       // Teal
            'confidence': '#FFD600', // Orange
            'threshold': '#00FF00'   // Lime
        };
        const mainParts = col.split('__');
        const suffix = (mainParts.length > 1 ? mainParts[1] : col.split('_').shift()).toLowerCase();
        color = 0;
        if (palette[suffix]) { 
            color = palette[suffix];
        } else {
            let hash = 0;
            for (let i = 0; i < col.length; i++) {
                hash = col.charCodeAt(i) + ((hash << 5) - hash);
            }
            color = `hsl(${Math.abs(hash % 360)}, 80%, 50%)`;
        }
        return color;
    }


    function clearOnUpdate() {
        masterData = [];
        candleSeries.setData([]);
        volumeSeries.setData([]);
        Object.values(overlaySeriesMap).forEach(s => mainChart.removeSeries(s));
        overlaySeriesMap = {};
        Object.values(panelCharts).forEach(p => p.chart.remove());
        panelCharts = {};
        document.getElementById('panel-container').innerHTML = '';
        candleSeries.priceScale().applyOptions({
            autoScale: true,
        });
    }

    function resetAndLoad(clear = false) {
        // Refresh the indicator list from the API
        const s = document.createElement('script');
        s.src = "/ohlcv/1.1/list/indicators/output/JSONP?callback=__bp_callback";
        document.body.appendChild(s);
        if (clear) {
            clearOnUpdate();
        } else{

            const timeScale = mainChart.timeScale();
            const range = timeScale.getVisibleLogicalRange();
            
            if (range && masterData.length > 0) {
                const firstVisibleIdx = Math.max(0, Math.floor(range.from));
                
                // Save the anchor-time to force the view to remain unchanged
                // See: additional logic in __callbackData
                window.anchorTime = masterData[firstVisibleIdx].time;               
                window.savedWidth = range.to - range.from;

                masterData = [];
                candleSeries.setData([]);
                volumeSeries.setData([]);

                hasMoreHistory = true;
                gapRetryCount = 0;
                // We go FORWARD direction since the reference time is the left bar!
                requestDirection = 'forward';
                // Do not forget that we are dealing with epoch_ms, so multiply by 1000
                loadData('forward', window.anchorTime*1000);

                return;
            }
        }
        hasMoreHistory = true;
        gapRetryCount = 0;
        loadData('initial');
    }

    function formatUnixToLiteral(unix) {
        const d = new Date(unix * 1000);
        return d.toISOString().replace('T', ' ').split('.')[0];
    }

    function updateTimeframeOptions() {
        const sym = document.getElementById('symbolSelect').value;
        const tfSelect = document.getElementById('tfSelect');
        const availableTfs = symbolData[sym] || [];
        
        const currentTf = tfSelect.value;

        tfSelect.innerHTML = availableTfs.map(tf => 
            `<option value="${tf}">${tf}</option>`
        ).join('');
        if (availableTfs.includes(currentTf)) {
            tfSelect.value = currentTf;
        } else {
            if (availableTfs.includes('1h')) {
                tfSelect.value = '1h';
            } else if (availableTfs.length > 0) {
                tfSelect.value = availableTfs[0];
            }
        }
    }

    window.__callbackList = (res) => {
        symbolData = res.result;
        const sel = document.getElementById('symbolSelect');
        sel.innerHTML = Object.keys(symbolData).sort().map(s => `<option value="${s}">${s}</option>`).join('');
        updateTimeframeOptions();
        resetAndLoad(true);
    };

    window.__bp_callback = (res) => {
        indicatorMeta = res.result;
        document.getElementById('indicatorSelect').innerHTML = Object.keys(indicatorMeta).map(i => `<option value="${i}">${i.toUpperCase()}</option>`).join('');
        renderParams();
    };

    document.addEventListener('DOMContentLoaded', () => {
        initCharts();
        const s1 = document.createElement('script'); s1.src = "/ohlcv/1.1/list/symbols/output/JSONP?callback=__callbackList"; document.body.appendChild(s1);
        const s2 = document.createElement('script'); s2.src = "/ohlcv/1.1/list/indicators/output/JSONP?callback=__bp_callback"; document.body.appendChild(s2);
        document.addEventListener('keydown', (e) => {
            const timeScale = mainChart.timeScale();
            const visibleRange = timeScale.getVisibleLogicalRange();
            if (!visibleRange) return;

            const barsInView = visibleRange.to - visibleRange.from;

            if (e.key === 'PageUp') {
                e.preventDefault();
                timeScale.setVisibleLogicalRange({
                    from: visibleRange.from - barsInView,
                    to: visibleRange.to - barsInView
                });
            } else if (e.key === 'PageDown') {
                e.preventDefault();
                timeScale.setVisibleLogicalRange({
                    from: visibleRange.from + barsInView,
                    to: visibleRange.to + barsInView
                });
            } else if (e.key === 'End') {
                e.preventDefault();
                timeScale.scrollToRealTime();
            }
        });
    });

    document.addEventListener('DOMContentLoaded', () => {
        const modal = document.getElementById('calendarModal');
        const btn = document.getElementById('calendarBtn');
        const close = document.getElementById('closeModal');
        const okBtn = document.getElementById('calendarOk');
        const dateInput = document.getElementById('calendarInput');

        btn.onclick = () => modal.style.display = 'flex';
        close.onclick = () => modal.style.display = 'none';
        window.onclick = (e) => { if (e.target == modal) modal.style.display = 'none'; };

        let isJumpRequest = false;
        let jumpBarCount = 1000;

        okBtn.onclick = () => {
            const val = dateInput.value;
            if (!val) return;

            const timeScale = mainChart.timeScale();
            const range = timeScale.getVisibleLogicalRange();
            const jumpBarCount = range ? Math.round(range.to - range.from) : 1000;

            const [year, month, day] = val.split('-').map(Number);
            modal.style.display = 'none';
            const referenceTs = Date.UTC(year, month - 1, day);

            masterData = [];
            candleSeries.setData([]);
            volumeSeries.setData([]);
            Object.values(overlaySeriesMap).forEach(s => mainChart.removeSeries(s));
            overlaySeriesMap = {};
            Object.values(panelCharts).forEach(p => p.chart.remove());
            panelCharts = {};
            document.getElementById('panel-container').innerHTML = '';

            const jumpToStart = () => {
                const newRange = timeScale.getVisibleLogicalRange();
                if (newRange && masterData.length > 0) {
                    timeScale.setVisibleLogicalRange({
                        from: 0,
                        to: jumpBarCount
                    });

                    candleSeries.priceScale().applyOptions({
                        autoScale: true,
                    });

                    timeScale.unsubscribeVisibleLogicalRangeChange(jumpToStart);
                }
            };

            timeScale.subscribeVisibleLogicalRangeChange(jumpToStart);
            loadData("future", referenceTs, jumpBarCount);
        };
    });

    document.addEventListener('DOMContentLoaded', () => {
        const themeToggle = document.getElementById('themeToggle');

        themeToggle.onclick = () => {
            isDark = !isDark;
            document.body.classList.toggle('dark-theme', isDark);
            themeToggle.innerText = isDark ? "â˜€ï¸ Light Mode" : "ðŸŒ™ Dark Mode";

            const themeColors = isDark ? {
                back: '#131722',
                text: '#d1d4dc',
                grid: '#2a2e39'
            } : {
                back: '#ffffff',
                text: '#131722',
                grid: '#f0f3fa'
            };

            mainChart.applyOptions({
                layout: { background: { color: themeColors.back }, textColor: themeColors.text },
                grid: {
                    vertLines: { color: themeColors.grid },
                    horzLines: { color: themeColors.grid },
                },
                timeScale: { borderColor: themeColors.grid }
            });
            Object.values(panelCharts).forEach(p => {
                p.chart.applyOptions({
                    layout: { background: { color: themeColors.back }, textColor: themeColors.text },
                    grid: {
                        vertLines: { color: themeColors.grid },
                        horzLines: { color: themeColors.grid },
                    }
                });
            });
        };
    });

</script>
</body>
</html>