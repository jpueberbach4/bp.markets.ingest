<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trading Interface - Charts</title>
    <script src="scripts/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --bg-main: #f0f3fa; --sidebar-dark: #131722; --accent-blue: #2962ff;
            --text-gray: #787b86; --white: #ffffff; --border-color: #e0e3eb;
        }

        body { 
            font-family: -apple-system, system-ui, sans-serif; background: var(--bg-main); 
            margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden;
        }

        header {
            background: var(--sidebar-dark); color: white; padding: 10px 20px;
            display: flex; align-items: center; justify-content: space-between; height: 50px;
        }

        .main-container { display: flex; flex: 1; overflow: hidden; }

        .sidebar { 
            width: 300px; background: var(--white); border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column; padding: 15px; overflow-y: auto;
        }

        .control-group { margin-bottom: 15px; }
        label { font-size: 11px; color: var(--text-gray); text-transform: uppercase; font-weight: 700; display: block; margin-bottom: 5px; }
        select, input { width: 100%; padding: 6px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 13px; box-sizing: border-box; }
        
        .param-box { background: #f8f9fd; padding: 10px; border-radius: 4px; border: 1px dashed var(--border-color); margin-top: 5px; }
        .indicator-tag { 
            background: #e3e9ff; color: var(--accent-blue); padding: 4px 8px; border-radius: 12px; 
            font-size: 11px; font-weight: 600; display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;
        }
        .add-btn { 
            background: var(--white); border: 1px solid var(--accent-blue); color: var(--accent-blue); 
            padding: 6px; border-radius: 4px; font-size: 11px; font-weight: 700; cursor: pointer; width: 100%; margin-top: 5px;
        }

        div[id^="tv-attr-logo"], 
        .tv-embed-widget-wrapper__attribution,
        #main-chart-container a[href*="tradingview.com"] {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        #chart-legend {
            position: absolute;
            z-index: 1000;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            color: #131722;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: none;
            line-height: 1.4;
        }

        .legend-ohlcv { font-weight: bold; border-bottom: 1px solid #eee; margin-bottom: 6px; padding-bottom: 4px; }
        .legend-item { display: flex; justify-content: space-between; margin-bottom: 2px; gap: 15px; }

        #content-wrapper { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden; 
        }

        #main-chart-container { 
            flex: 1 1 auto; 
            min-height: 0; 
            position: relative; 
        }

        #panel-container { 
            flex: 0 0 auto; 
            display: flex; 
            flex-direction: column;
            background: #fcfcfc;
            overflow-y: auto;
            max-height: 60vh;
        }

        .indicator-panel { 
            height: 130px; 
            flex-shrink: 0;
            border-top: 1px solid #444;
            background: white; 
        }

        .sidebar-footer { 
            padding: 15px 20px; 
            border-top: 1px solid var(--border-color); 
            background: #fafbfc; 
            text-align: center; 
            margin-top: auto;
        }

        .attribution { 
            font-size: 14px; 
            color: var(--text-gray); 
            text-decoration: none; 
        }

        .attribution strong { 
            color: #5d606b; 
        }

        #loader {
            display: none; 
            position: absolute; 
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0); 
            z-index: 100; 
            justify-content: center; 
            align-items: center;
            pointer-events: none; 
        }

        .spinner {
            width: 24px; height: 24px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        #export-modal {
            display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); align-items: center; justify-content: center;
        }
        .modal-content {
            background: white; padding: 25px; border-radius: 8px; width: 320px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        .modal-content h3 { margin-top: 0; font-size: 16px; color: var(--sidebar-dark); }
        .export-field { margin-bottom: 15px; }
        .export-checkboxes { display: flex; gap: 15px; margin-bottom: 20px; font-size: 12px; }
        .cancel-btn { 
            background: #e0e3eb; color: #131722; border: none; padding: 10px; 
            border-radius: 4px; font-weight: 600; cursor: pointer; width: 48%; 
        }
        .exec-btn { 
            background: var(--accent-blue); color: white; border: none; padding: 10px; 
            border-radius: 4px; font-weight: 600; cursor: pointer; width: 48%; 
        }        

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <header>
        <h2 style="margin:0; font-size: 18px;">Interactive Stream</h2>
        <div id="status-indicator" style="font-size: 11px; opacity: 0.8;">Initialising...</div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <div class="control-group">
                <label>Symbol</label>
                <select id="symbolSelect" onchange="updateTimeframeOptions(); resetAndLoad(true);"></select>
            </div>
            <div class="control-group">
                <label>Interval</label>
                <select id="tfSelect" onchange="resetAndLoad(true)"></select>
            </div>

            <hr style="border:0; border-top:1px solid #eee; margin: 15px 0;">

            <div class="control-group">
                <label>Add Indicator</label>
                <select id="indicatorSelect" onchange="renderParams()"></select>
                <div id="params" class="param-box"></div>
                <button class="add-btn" onclick="addToChain()">+ Add to Chart</button>
            </div>

            <div class="control-group">
                <label>Active Indicators</label>
                <div id="chain-list"></div>
            </div>

            <button onclick="resetAndLoad(false)" style="margin-top:auto; background: var(--accent-blue); color:white; border:none; padding:10px; border-radius:4px; font-weight:600; cursor:pointer;">Update View</button>

            <button onclick="openExportModal()" style="margin-top:10px; background: #313339; color:white; border:none; padding:10px; border-radius:4px; font-weight:600; cursor:pointer; width:100%;">Export View</button>

            <div class="sidebar-footer">
                <a href="https://www.dukascopy.com" target="_blank" class="attribution">
                    Market data by <strong>Dukascopy</strong>
                </a>
            </div>
        </div>

        <div id="content-wrapper">
            <div id="loader"><div class="spinner"></div></div>
            <div id="chart-legend"></div>
            <div id="main-chart-container"></div>
            <div id="panel-container"></div>
        </div>
    </div>

    <div id="export-modal">
        <div class="modal-content">
            <h3>Export Settings</h3>
            <div class="export-field">
                <label>Start Date (After)</label>
                <input type="text" id="export-after" placeholder="YYYY-MM-DD HH:MM:SS">
            </div>
            <div class="export-field">
                <label>Total Records (Limit)</label>
                <input type="number" id="export-limit" value="1000">
            </div>
            <div class="export-field">
                <label>Order</label>
                <select id="export-order">
                    <option value="asc">Ascending</option>
                    <option value="desc">Descending</option>
                </select>
            </div>
            <div class="export-checkboxes">
                <label><input type="checkbox" id="export-mt4"> MT4 CSV</label>
                <label><input type="checkbox" id="export-skiplast"> SkipLast</label>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <button class="cancel-btn" onclick="document.getElementById('export-modal').style.display='none'">Cancel</button>
                <button class="exec-btn" onclick="runExport()">Download</button>
            </div>
        </div>
    </div>
<script>
        let symbolData = {}; 
        let indicatorMeta = {};
        let chain = []; 
        let masterData = []; 
        let isFetching = false;

        let currentAfterDate = new Date();
        let currentUntilDate = null;
        let hasMoreHistory = true;
        let gapRetryCount = 0;
        let isManualReset = false;
        let shouldResetZoomOnNextLoad = false;
        const initialMaxSearches = 100;
        const normalMaxSearches = 10;
        let minimumPriceWidth = 80
        let currentMaxSearches = initialMaxSearches;
        
        let mainChart, candleSeries;
        let overlaySeries = []; 
        let panelCharts = {};
        let overlaySeriesMap = {}; 
        let volumeSeries; 

        const mainContainer = document.getElementById('main-chart-container');

        function openExportModal() {
            const modal = document.getElementById('export-modal');
            const dateInput = document.getElementById('export-after');
            
            if (masterData.length > 0) {
                dateInput.value = formatUnixToLiteral(masterData[0].time);
            } else {
                dateInput.value = formatUnixToLiteral(Math.floor(Date.now() / 1000));
            }
            
            modal.style.display = 'flex';
        }

        function runExport() {
            const sym = document.getElementById('symbolSelect').value;
            let tf = document.getElementById('tfSelect').value;
            
            if (document.getElementById('export-skiplast').checked) tf += ':skiplast';
            const output = document.getElementById('export-mt4').checked ? 'CSV/MT4' : 'CSV';
            
            const after = encodeURIComponent(document.getElementById('export-after').value);
            const limit = document.getElementById('export-limit').value;
            const order = document.getElementById('export-order').value;
            
            const chainStr = chain.length ? `[${chain.map(i => `${i.name}(${i.params.join(',')})`).join(':')}]` : "";
            
            const exportUrl = `/ohlcv/1.1/select/${sym},${tf}${chainStr}/after/${after}/output/${output}?limit=${limit}&order=${order}`;
            
            window.location.href = exportUrl;
        }

        function initCharts() {
            mainChart = LightweightCharts.createChart(mainContainer, {
                width: mainContainer.clientWidth,
                height: mainContainer.clientHeight,

                localization: {
                            timeFormatter: (unixTimestamp) => {
                                return formatUnixToLiteral(unixTimestamp);
                            },
                        },
                layout: { background: { color: '#ffffff' }, textColor: '#131722',attributionLogo: false },
                timeScale: { timeVisible: true, borderColor: '#e0e3eb' },
                rightPriceScale: {
                    borderVisible: false,
                    minimumWidth: minimumPriceWidth
                },
            });

            const resizeObserver = new ResizeObserver(entries => {
                if (entries.length === 0 || !entries[0].contentRect) return;
                const { width, height } = entries[0].contentRect;
                mainChart.applyOptions({ width, height, rightPriceScale: { minimumWidth: minimumPriceWidth} });
            });
            resizeObserver.observe(mainContainer);

            candleSeries = mainChart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: '#26a69a', downColor: '#ef5350', borderVisible: false,
                wickUpColor: '#26a69a', wickDownColor: '#ef5350',
                priceFormat: {
                    type: 'price',
                    precision: 5,      // Sets the number of decimal places
                    minMove: 0.00001,  // Matches the 5-decimal precision
                },
            });
            
            volumeSeries = mainChart.addSeries(LightweightCharts.HistogramSeries, {
                color: '#26a69a',
                priceFormat: { type: 'volume' },
                priceScaleId: '',
            });
            volumeSeries.priceScale().applyOptions({
                scaleMargins: { top: 0.8, bottom: 0 }, 
            });

            const legend = document.getElementById('chart-legend');

            mainChart.subscribeCrosshairMove(param => {
                if (!param.time || param.point === undefined || param.point.x < 0 || param.point.y < 0) {
                    legend.style.display = 'none';
                    return;
                }

                const data = param.seriesData.get(candleSeries);
                const volData = param.seriesData.get(volumeSeries);
                if (!data) return;

                legend.style.display = 'block';
                legend.style.left = (param.point.x + 165) + 'px'; 
                legend.style.top = (param.point.y + 65) + 'px';
                
                let html = `<div class="legend-ohlcv">`;
                html += `<div style="color: var(--text-gray); font-size: 10px; margin-bottom: 4px;">${formatUnixToLiteral(param.time)}</div>`;
                html += `O: ${data.open} H: ${data.high}<br>L: ${data.low} C: ${data.close}`;
                if (volData) html += `<br>Vol: ${volData.value.toLocaleString()}`;
                html += `</div>`;
                const masterPoint = masterData.find(d => d.time === param.time);
                if (masterPoint && masterPoint.indicators) {
                    chain.forEach(item => {
                        const key = item.params.length ? `${item.name}_${item.params.join('_')}` : `${item.name}_`;
                        const val = masterPoint.indicators[key];
                        const settings = item.params.length ? `(${item.params.join(',')})` : '';

                        if (val !== undefined) {
                            if (typeof val === 'object') {
                                Object.entries(val).forEach(([k, v]) => {
                                    html += `<div class="legend-item"><span>${item.name}${settings} [${k}]</span> <b style="color:${item.color || '#2962ff'}">${v.toFixed(4)}</b></div>`;
                                });
                            } else {
                                html += `<div class="legend-item"><span>${item.name}${settings}</span> <b style="color:${item.color || '#7e57c2'}">${val.toFixed(4)}</b></div>`;
                            }
                        }
                    });
                }
                legend.innerHTML = html;
            });

            mainChart.timeScale().subscribeVisibleLogicalRangeChange(() => {
                requestAnimationFrame(checkIfChartFull);
            });


        }

        function resetAndLoad(clear = false) {
            isManualReset = true;
            if (clear) {
                masterData = [];
                candleSeries.setData([]);
                if(volumeSeries) volumeSeries.setData([]);
                overlaySeries.forEach(s => mainChart.removeSeries(s));
                overlaySeries = [];
                overlaySeriesMap = {};

                Object.values(panelCharts).forEach(p => p.chart.remove());
                document.getElementById('panel-container').innerHTML = '';
                panelCharts = {};
                shouldResetZoomOnNextLoad = true;
            }

            currentMaxSearches = initialMaxSearches;
            hasMoreHistory = true; 
            gapRetryCount = 0;
            currentUntilDate = null; 
            const tf = document.getElementById('tfSelect').value;
            const initialOffset = getTimeframeOffset(tf) / 2;
            currentAfterDate = new Date(Date.now() - initialOffset);

            loadData();
        }

        function paginateBack() {
            if (isFetching || !hasMoreHistory || masterData.length === 0) return;
            isManualReset = false;
    
            const tf = document.getElementById('tfSelect').value;
            const referenceTime = masterData[0].time;
            const untilUnix = referenceTime - 1;
            currentUntilDate = new Date(untilUnix * 1000);
            const baseOffset = getTimeframeOffset(tf);
            const jumpSize = baseOffset * (gapRetryCount + 1); 
            const afterUnix = untilUnix - (jumpSize / 1000);
            currentAfterDate = new Date(afterUnix * 1000);
            loadData();
        }

        function checkIfChartFull() {
            if (isFetching || masterData.length === 0 || !hasMoreHistory) return;
            const timeScale = mainChart.timeScale();
            const visibleRange = timeScale.getVisibleRange();
            if (visibleRange && visibleRange.from <= masterData[0].time) paginateBack();
        }

        function loadData() {
            const sym = document.getElementById('symbolSelect').value;
            const tf = document.getElementById('tfSelect').value;
            if(!sym || !tf || isFetching) return;

            isFetching = true;
            document.getElementById('loader').style.display = 'flex';

            const afterStr = formatUnixToLiteral(Math.floor(currentAfterDate.getTime() / 1000));
            const chainStr = chain.length ? `[${chain.map(i => `${i.name}(${i.params.join(',')})`).join(':')}]` : "";
            
            let url = `/ohlcv/1.1/select/${sym},${tf}${chainStr}/after/${afterStr}`;
            if (currentUntilDate) {
                url += `/until/${formatUnixToLiteral(Math.floor(currentUntilDate.getTime() / 1000))}`;
            }
            url += `/output/JSONP?order=asc&limit=1440&callback=__callbackData`;

            const s = document.createElement('script');
            s.src = url;
            document.body.appendChild(s);
        }

        window.__callbackData = function(response) {
            isFetching = false;
            document.getElementById('loader').style.display = 'none';
            const statusIndicator = document.getElementById('status-indicator');

            if (response.result && response.result.length > 0) {
                currentMaxSearches = normalMaxSearches;
                gapRetryCount = 0;

                const incoming = response.result.map(row => {
                    const isUp = row.close >= row.open;
                    return {
                        time: parseLiteralToUnix(row.time),
                        open: row.open, high: row.high, low: row.low, close: row.close,
                        value: row.volume,
                        candleColor: isUp ? '#26a69a' : '#ef5350', 
                        volumeColor: isUp ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)',
                        indicators: row.indicators
                    };
                });

                const combined = [...masterData, ...incoming];
                const uniqueMap = new Map();
                combined.forEach(item => { if(item.time) uniqueMap.set(item.time, item); });
                masterData = Array.from(uniqueMap.values()).sort((a, b) => a.time - b.time);

                candleSeries.setData(masterData.map(d => ({
                    time: d.time, open: d.open, high: d.high, low: d.low, close: d.close,
                    color: d.candleColor,
                    borderColor: d.candleColor,
                    wickColor: d.candleColor
                })));

                volumeSeries.setData(masterData.map(d => ({ 
                    time: d.time, 
                    value: d.value, 
                    color: d.volumeColor 
                })));
                renderIndicators();

                if (shouldResetZoomOnNextLoad) {
                    mainChart.timeScale().fitContent();
                    shouldResetZoomOnNextLoad = false;
                }
                
                statusIndicator.innerText = `Data Synced: ${masterData.length} candles`;
                setTimeout(checkIfChartFull, 200);
            } else {
                if (gapRetryCount < currentMaxSearches) {
                    gapRetryCount++;
                    statusIndicator.innerText = `Searching History... (${gapRetryCount}/${currentMaxSearches})`;
                    if (masterData.length === 0) {
                        const tf = document.getElementById('tfSelect').value;
                        currentUntilDate = new Date(currentAfterDate.getTime() - 1000);
                        currentAfterDate = new Date(currentUntilDate.getTime() - getTimeframeOffset(tf));
                        loadData();
                    } else {
                        paginateBack(); 
                    }
                } else {
                    hasMoreHistory = false;
                    statusIndicator.innerText = `History Limit Reached`;
                }
            }
        };

        function renderIndicators() {
            if (isManualReset) {
                overlaySeries.forEach(s => mainChart.removeSeries(s));
                overlaySeries = [];
            }

            chain.forEach(item => {
                const meta = indicatorMeta[item.name];
                const key = item.params.length ? `${item.name}_${item.params.join('_')}` : `${item.name}_`;
                
                if (meta && meta.meta && meta.meta.panel === 1) {
                    renderPanel(item, key);
                } else {
                    renderOverlay(item, key);
                }
            });
        }

        function renderOverlay(item, key) {
            const sampleEntry = masterData.find(d => d.indicators && d.indicators[key] !== undefined);
            const sample = sampleEntry ? sampleEntry.indicators[key] : null;

            if (!item.color) item.color = getRandomColor();
            const settings = item.params.length ? `(${item.params.join(',')})` : '';

            if (sample !== null && typeof sample === 'object') {
                Object.keys(sample).forEach(lineName => {
                    const seriesId = `${item.id}_${lineName}`;
                    
                    if (!overlaySeriesMap[seriesId]) {
                        const series = mainChart.addSeries(LightweightCharts.LineSeries, { 
                            title: `${item.name}${settings} [${lineName}]`, 
                            lineWidth: 1,
                            color: getOverlayColor(item.name, lineName, item.color)
                        });
                        overlaySeriesMap[seriesId] = series;
                        overlaySeries.push(series);
                    }

                    const lineData = masterData.map(d => ({
                        time: d.time,
                        value: d.indicators[key] ? d.indicators[key][lineName] : null
                    })).filter(v => v.value !== null && v.value !== undefined);
                    
                    overlaySeriesMap[seriesId].setData(lineData);
                });
            } else {
                const seriesId = item.id;
                
                if (!overlaySeriesMap[seriesId]) {
                    const series = mainChart.addSeries(LightweightCharts.LineSeries, { 
                        title: `${item.name}${settings}`, 
                        lineWidth: 2,
                        color: item.color
                    });
                    overlaySeriesMap[seriesId] = series;
                    overlaySeries.push(series);
                }

                const data = masterData.map(d => ({
                    time: d.time,
                    value: d.indicators ? d.indicators[key] : null
                })).filter(p => p.value !== null && p.value !== undefined);
                
                overlaySeriesMap[seriesId].setData(data);
            }
        }

        function getOverlayColor(indicatorName, lineName, baseColor) {
            const name = indicatorName.toLowerCase();
            const line = lineName.toLowerCase();
            if (name.includes('bbands')) {
                if (line.includes('upper') || line.includes('lower')) return '#2196F3'; 
                return '#FF9800'; 
            }
            if (name.includes('ichimoku')) {
                const ichiColors = {
                    'tenkan': '#0496ff', 'kijun': '#991515', 
                    'senkou_a': '#26a69a', 'senkou_b': '#ef5350', 'chikou': '#7e57c2'
                };
                return ichiColors[line] || baseColor;
            }
            return baseColor;
        }



        function renderPanel(item, key) {
            if (!panelCharts[item.id]) {
                const container = document.getElementById('panel-container');
                const div = document.createElement('div');
                div.className = 'indicator-panel';
                div.id = `panel_${item.id}`;
                div.style.position = 'relative';
                container.appendChild(div);

                const panelTitle = document.createElement('div');
                const settings = item.params.length ? `(${item.params.join(',')})` : '';
                panelTitle.innerText = `${item.name.toUpperCase()}${settings}`;
                panelTitle.style.cssText = `
                    position: absolute;
                    top: 5px;
                    left: 5px;
                    z-index: 2;
                    font-size: 11px;
                    font-weight: bold;
                    color: #131722;
                    background-color: rgba(240, 243, 250, 0.85); /* Light grey with slight transparency */
                    padding: 2px 6px;
                    border-radius: 4px;
                    border: 1px solid #e0e3eb;
                    pointer-events: none;
                    font-family: -apple-system, system-ui, sans-serif;
                `;
                div.appendChild(panelTitle);

                const pChart = LightweightCharts.createChart(div, {
                    height: 150, 
                    layout: { background: { color: 'transparent' }, textColor: '#131722', attributionLogo: false}, //
                    timeScale: { visible: false }, 
                    rightPriceScale: {
                        borderVisible: false,
                        minimumWidth: minimumPriceWidth
                    }
                });

                const panelResizeObserver = new ResizeObserver(entries => {
                    if (entries.length === 0 || !entries[0].contentRect) return;
                    const { width, height } = entries[0].contentRect;
                    pChart.applyOptions({ width, height, rightPriceScale: {minimumWidth: minimumPriceWidth} });
                });
                panelResizeObserver.observe(div);

                mainChart.timeScale().subscribeVisibleLogicalRangeChange(range => {
                    if (range) pChart.timeScale().setVisibleLogicalRange(range); 
                });

                panelCharts[item.id] = { chart: pChart, series: {} };
            }
            updatePanelData(item, key);
        }

        function updatePanelData(item, key) {
            const pObj = panelCharts[item.id];
            const sampleEntry = masterData.find(d => d.indicators && d.indicators[key] !== undefined);
            const sample = sampleEntry ? sampleEntry.indicators[key] : null;

            if (sample !== null && typeof sample === 'object') {
                Object.keys(sample).forEach(lineName => {
                    if (!pObj.series[lineName]) {
                        const isHist = lineName === 'hist' || lineName === 'histogram';
                        const type = isHist ? LightweightCharts.HistogramSeries : LightweightCharts.LineSeries;
                        const color = isHist ? '#ef5350' : (lineName === 'macd' ? '#2962ff' : getRandomColor());
                        
                        pObj.series[lineName] = pObj.chart.addSeries(type, { 
                            title: lineName, 
                            color: color,
                            lineWidth: 1,
                            priceFormat: {
                                type: 'price',
                                precision: 5,
                                minMove: 0.00001,
                            },
                        });
                    }
                    
                    const lineData = masterData.map(d => ({
                        time: d.time,
                        value: d.indicators[key] ? d.indicators[key][lineName] : null
                    })).filter(v => v.value !== null);
                    
                    pObj.series[lineName].setData(lineData);
                });
            } else {
                if (!pObj.series['main']) {
                    pObj.series['main'] = pObj.chart.addSeries(LightweightCharts.LineSeries, { 
                        title: item.name, 
                        color: '#7e57c2',
                        lineWidth: 1, // ADD THIS LINE TO FIX THE RSI WIDTH
                        priceFormat: {
                            type: 'price',
                            precision: 5,
                            minMove: 0.00001,
                        },
                    });
                }
                
                const lineData = masterData.map(d => ({
                    time: d.time,
                    value: d.indicators ? d.indicators[key] : null
                })).filter(v => v.value !== null);
                
                pObj.series['main'].setData(lineData);
            }
        }

        function getRandomColor() {
            const colors = ['#2962ff', '#ff6d00', '#2e7d32', '#6a1b9a', '#f50057', '#00b8d4'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        window.addEventListener('keydown', (event) => {
            if (masterData.length === 0) return;
            const timeScale = mainChart.timeScale();
            const visibleRange = timeScale.getVisibleLogicalRange();
            if (!visibleRange) return;
            const rangeWidth = visibleRange.to - visibleRange.from;

            if (event.key === 'PageUp') {
                event.preventDefault();
                timeScale.setVisibleLogicalRange({ from: visibleRange.from - rangeWidth, to: visibleRange.to - rangeWidth });
            } else if (event.key === 'PageDown') {
                event.preventDefault();
                timeScale.setVisibleLogicalRange({ from: visibleRange.from + rangeWidth, to: visibleRange.to + rangeWidth });
            } else if (event.key === 'End') {
                event.preventDefault();
                timeScale.scrollToPosition(0, true);
            }
        });

        function renderParams() {
            const ind = document.getElementById('indicatorSelect').value;
            const meta = indicatorMeta[ind];
            const container = document.getElementById('params');
            if (meta && meta.defaults) {
                container.innerHTML = Object.keys(meta.defaults).map(k => `
                    <div style="margin-bottom:5px">
                        <label style="font-size:9px; margin-bottom:2px">${k}</label>
                        <input type="text" id="p_${k}" value="${meta.defaults[k]}">
                    </div>`).join('');
            } else {
                container.innerHTML = '<span style="color:#999; font-size:11px">No parameters</span>';
            }
        }

        function addToChain() {
            const name = document.getElementById('indicatorSelect').value;
            const meta = indicatorMeta[name];
            const params = meta.defaults ? Object.keys(meta.defaults).map(k => document.getElementById(`p_${k}`).value) : [];
            chain.push({ 
                name, 
                params, 
                id: `${name}_${Date.now()}`,
                color: getRandomColor() 
            });
            
            renderChain();
            resetAndLoad(true);
        }

        function renderChain() {
            document.getElementById('chain-list').innerHTML = chain.map((item, i) => `
                <div class="indicator-tag">
                    <span>${item.name}(${item.params.join(',')})</span>
                    <span style="cursor:pointer" onclick="chain.splice(${i},1); renderChain(); resetAndLoad(true);">âœ•</span>
                </div>`).join('');
        }

        function formatUnixToLiteral(unix) {
            const d = new Date(unix * 1000);
            const pad = (n) => n.toString().padStart(2, '0');
            return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
        }

        function parseLiteralToUnix(dateStr) {
            const parts = dateStr.split(/[- :]/);
            return Math.floor(new Date(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5]).getTime() / 1000);
        }

        function updateTimeframeOptions() {
            const sym = document.getElementById('symbolSelect').value;
            const tfS = document.getElementById('tfSelect');
            const currentTf = tfS.value;
            const options = (symbolData[sym] || []);
            tfS.innerHTML = options.map(tf => `<option value="${tf}">${tf}</option>`).join('');
            if (currentTf && options.includes(currentTf)) {
                tfS.value = currentTf;
            }
        }

        function getTimeframeOffset(tf) {
            const day = 24 * 60 * 60 * 1000;
            switch (tf) {
                case '1Y': case '1M': return 3650 * day; case '1W': return 730 * day;
                case '1d': return 365 * day; case '4h': return 100 * day; case '1h': return 30 * day;
                case '30m': return 15 * day; case '15m': return 7 * day; case '5m': return 2 * day;
                case '1m': return 1 * day; 
                default:
                    if (tf.includes('M')) return 3650 * day;
                    if (tf.includes('W')) return 1460 * day;
                    if (tf.includes('h')) return 60 * day;
                    if (tf.includes('m')) return 4 * day;
                    return 4 * day;
            }
        }

        window.__callbackList = (res) => {
            symbolData = res.result;
            const sel = document.getElementById('symbolSelect');
            sel.innerHTML = Object.keys(symbolData).sort().map(s => `<option value="${s}">${s}</option>`).join('');
            updateTimeframeOptions();
            resetAndLoad(true);
        };

        window.__bp_callback = (res) => {
            indicatorMeta = res.result;
            document.getElementById('indicatorSelect').innerHTML = Object.keys(indicatorMeta).map(i => `<option value="${i}">${i.toUpperCase()}</option>`).join('');
            renderParams();
        };

        document.addEventListener('DOMContentLoaded', () => {
            initCharts();
            const s1 = document.createElement('script');
            s1.src = "/ohlcv/1.1/list/symbols/output/JSONP?callback=__callbackList";
            document.body.appendChild(s1);
            const s2 = document.createElement('script');
            s2.src = "/ohlcv/1.1/list/indicators/output/JSONP?callback=__bp_callback";
            document.body.appendChild(s2);
        });
    </script>
</body>
</html>